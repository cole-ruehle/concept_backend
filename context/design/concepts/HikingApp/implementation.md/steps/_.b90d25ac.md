---
timestamp: 'Thu Oct 16 2025 21:11:45 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251016_211145.2ab12201.md]]'
content_id: b90d25acd6b414edc7e75f1a31ea1a99fcad0d4ead135fe45cac2c153e519881
---

# Implement Tests in the following style.

import {
assert,
assertEquals,
assertRejects,
assertNotEquals,
} from "https://deno.land/std@0.224.0/assert/mod.ts";
import { beforeAll, afterAll, describe, it } from "https://deno.land/std@0.224.0/testing/bdd.ts";
import {
TransitRoutePlannerConcept,
connectMongo,
ensureCollections,
ValidationError,
NotFoundError,
TransitRoutePlannerLLM,
TRANSIT\_STOPS\_COLLECTION,
TRAILHEADS\_COLLECTION,
TRAILS\_COLLECTION,
PLANNED\_ROUTES\_COLLECTION,
} from "./TransitRoutePlanner.ts";
import { Db, ObjectId } from "npm:mongo";
import { load } from "https://deno.land/std@0.224.0/dotenv/mod.ts";

// --- Test Setup ---
const env = await load({ export: true });
const MONGODB\_URL = Deno.env.get("MONGODB\_URL");
const DB\_NAME\_BASE = Deno.env.get("DB\_NAME");

if (!MONGODB\_URL || !DB\_NAME\_BASE) {
throw new Error("MONGODB\_URL and DB\_NAME must be set in the environment.");
}

const DB\_NAME\_TEST = `${DB_NAME_BASE}-test`;

describe("TransitRoutePlannerConcept", () => {
let db: Db;
let planner: TransitRoutePlannerConcept;
let testData: {
originStopId: string;
destStopId: string;
trailheadId: string;
trailShortId: string;
trailLongId: string;
trailScenicId: string;
};

beforeAll(async () => {
db = await connectMongo(MONGODB\_URL, DB\_NAME\_TEST);
await ensureCollections(db);
planner = new TransitRoutePlannerConcept(db);

```
// Clean up before seeding
await Promise.all([
    db.collection(TRANSIT_STOPS_COLLECTION).deleteMany({}),
    db.collection(TRAILHEADS_COLLECTION).deleteMany({}),
    db.collection(TRAILS_COLLECTION).deleteMany({}),
    db.collection(PLANNED_ROUTES_COLLECTION).deleteMany({}),
]);

// Seed data
const originStopRes = await db.collection(TRANSIT_STOPS_COLLECTION).insertOne({
  _id: new ObjectId(),
  name: "Downtown Central",
  loc: { type: "Point", coordinates: [-122.4194, 37.7749] }, // San Francisco
  routes: ["5R", "N"],
});
const destStopRes = await db.collection(TRANSIT_STOPS_COLLECTION).insertOne({
  _id: new ObjectId(),
  name: "Mountain View Transit Center",
  loc: { type: "Point", coordinates: [-122.0763, 37.3942] }, // Near a hiking area
  routes: ["22", "522"],
});
const trailShortRes = await db.collection(TRAILS_COLLECTION).insertOne({
  _id: new ObjectId(), name: "Creek Loop", minutes: 45 
});
const trailLongRes = await db.collection(TRAILS_COLLECTION).insertOne({
  _id: new ObjectId(), name: "Ridge Trail", minutes: 120 
});
const trailScenicRes = await db.collection(TRAILS_COLLECTION).insertOne({
  _id: new ObjectId(), name: "Ocean View Path", minutes: 75, description: "A beautiful coastal walk."
});
const trailheadRes = await db.collection(TRAILHEADS_COLLECTION).insertOne({
  _id: new ObjectId(),
  name: "Rancho San Antonio Trailhead",
  loc: { type: "Point", coordinates: [-122.08, 37.39] }, // Close to dest stop
  connectingTrailIds: [
    trailShortRes.toHexString(),
    trailLongRes.toHexString(),
    trailScenicRes.toHexString(),
  ],
});

testData = {
    originStopId: originStopRes.toHexString(),
    destStopId: destStopRes.toHexString(),
    trailheadId: trailheadRes.toHexString(),
    trailShortId: trailShortRes.toHexString(),
    trailLongId: trailLongRes.toHexString(),
    trailScenicId: trailScenicRes.toHexString(),
};
```

});

afterAll(async () => {
await db.dropDatabase();
await db.client.close();
});

it("Operational Principle (happy path): should plan a feasible route", async () => {
const originLat = 37.775;
const originLon = -122.419;
const maxTravelMinutes = 300; // 5 hours

```
console.log("\n--- Testing Happy Path ---");
console.log(`Input: origin=(${originLat},${originLon}), trailheadId=${testData.trailheadId}, maxTime=${maxTravelMinutes}min`);

const routeId = await planner.planRoute(
  originLat,
  originLon,
  testData.trailheadId,
  maxTravelMinutes
);
assert(ObjectId.isValid(routeId), "Should return a valid ObjectId string");

const summary = await planner.getPlannedRouteSummary(routeId);
console.log("Output Summary:", summary);

assertEquals(summary.id, routeId);
assertEquals(summary.totalMinutes, summary.transitMinutes + summary.hikingMinutes);
assert(summary.hikingMinutes > 0, "Hiking minutes should be positive");
assert(summary.totalMinutes <= maxTravelMinutes, "Total time should not exceed max");
// Default behavior is to pick the longest hike that fits
assertEquals(summary.hikingMinutes, 120, "Should have picked the longest trail");
```

});

it("Scenario: Tight time window should select a shorter hike", async () => {
const originLat = 37.775;
const originLon = -122.419;
// Estimated transit is ~90-100 mins round trip.
// 150 mins total leaves ~50-60 mins for hiking. Should pick the 45-min trail.
const maxTravelMinutes = 150;

```
console.log("\n--- Testing Tight Time Window ---");
console.log(`Input: maxTime=${maxTravelMinutes}min`);

const routeId = await planner.planRoute(
  originLat,
  originLon,
  testData.trailheadId,
  maxTravelMinutes
);
const summary = await planner.getPlannedRouteSummary(routeId);
console.log("Output Summary:", summary);

assertEquals(summary.hikingMinutes, 45, "Should have picked the shorter 45-min trail");
```

});

it("Scenario: Zero/negative remaining time should throw ValidationError", async () => {
console.log("\n--- Testing Insufficient Time ---");
await assertRejects(
() => planner.planRoute(37.775, -122.419, testData.trailheadId, 60), // Not enough time
ValidationError,
"Insufficient time for hiking"
);
console.log("Correctly threw ValidationError for insufficient time.");
});

it("Scenario: getAlternativeRoutes('shorter') should return a shorter hike", async () => {
const originalRouteId = await planner.planRoute(37.775, -122.419, testData.trailheadId, 300);
const originalSummary = await planner.getPlannedRouteSummary(originalRouteId);
assertEquals(originalSummary.hikingMinutes, 120); // Starts with the long hike

```
console.log("\n--- Testing getAlternativeRoutes('shorter') ---");
const [altRouteId] = await planner.getAlternativeRoutes(originalRouteId, "shorter");
assert(altRouteId, "Should return an alternative route ID");
assertNotEquals(altRouteId, originalRouteId);

const altSummary = await planner.getPlannedRouteSummary(altRouteId);
console.log("Original Summary:", originalSummary);
console.log("Shorter Alt Summary:", altSummary);

assert(altSummary.hikingMinutes < originalSummary.hikingMinutes, "Alternative hike should be shorter");
assertEquals(altSummary.hikingMinutes, 45); // The shortest available
```

});

it("Scenario: updateRouteConstraints with a smaller limit should return a new valid route or null", async () => {
const originalRouteId = await planner.planRoute(37.775, -122.419, testData.trailheadId, 300);
const originalSummary = await planner.getPlannedRouteSummary(originalRouteId);
assertEquals(originalSummary.hikingMinutes, 120);

```
console.log("\n--- Testing updateRouteConstraints (feasible) ---");
const updatedRouteId = await planner.updateRouteConstraints(originalRouteId, 180); // Tighter budget
assert(updatedRouteId, "Should return a new route ID for a feasible update");
const updatedSummary = await planner.getPlannedRouteSummary(updatedRouteId as string);
console.log("Updated Summary (180 min):", updatedSummary);
assert(updatedSummary.hikingMinutes < originalSummary.hikingMinutes);
assertEquals(updatedSummary.hikingMinutes, 75); // Should pick the 75 min trail

console.log("\n--- Testing updateRouteConstraints (infeasible) ---");
const nullRouteId = await planner.updateRouteConstraints(originalRouteId, 80); // Impossible budget
console.log("Updated Summary (80 min):", nullRouteId);
assertEquals(nullRouteId, null, "Should return null for an infeasible update");
```

});

it("Scenario: 'scenic' criteria with mock LLM should select the specific scenic trail", async () => {
// Mock LLM that identifies "Ocean View Path" as scenic
const mockLLM: TransitRoutePlannerLLM = {
async classifyScenic(trailName: string): Promise<boolean> {
return trailName === "Ocean View Path";
}
};
const scenicPlanner = new TransitRoutePlannerConcept(db, mockLLM);
const originalRouteId = await scenicPlanner.planRoute(37.775, -122.419, testData.trailheadId, 300);

```
  console.log("\n--- Testing getAlternativeRoutes('scenic') with Mock LLM ---");
  const [scenicRouteId] = await scenicPlanner.getAlternativeRoutes(originalRouteId, "scenic");
  assert(scenicRouteId, "Should return a scenic alternative");
  
  const routeDoc = await db.collection(PLANNED_ROUTES_COLLECTION).findOne({_id: new ObjectId(scenicRouteId)});
  
  assertEquals(routeDoc?.hikingSegments[0].trailId, testData.trailScenicId);
  assertEquals(routeDoc?.hikingMinutes, 75);
  console.log("Correctly selected the mock scenic trail (75 min).");
```

});

it("Error Handling: Should throw NotFoundError for invalid IDs", async () => {
console.log("\n--- Testing NotFoundError ---");
const invalidId = new ObjectId().toHexString();
await assertRejects(
() => planner.getPlannedRouteSummary(invalidId),
NotFoundError,
`Planned route with id ${invalidId} not found.`
);
await assertRejects(
() => planner.getTrailheadCoords(invalidId),
NotFoundError,
`Trailhead with id ${invalidId} not found.`
);
console.log("Correctly threw NotFoundError for invalid IDs.");
});
});
